#pragma once

#include "IED/ConfigStore.h"
#include "IED/GlobalProfileManager.h"
#include "IED/StringHolder.h"

#include "IED/UI/Widgets/UIProfileSelectorWidget.h"
#include "Widgets/UINodeOverrideEditorWidget.h"

namespace IED
{
	class Controller;

	namespace UI
	{
		template <class T>
		class UINodeOverrideEditorCommon :
			public UINodeOverrideEditorWidget<T>,
			public UIProfileSelectorWidget<
				profileSelectorParamsNodeOverride_t<T>,
				NodeOverrideProfile>
		{
		public:
			UINodeOverrideEditorCommon(
				Controller& a_controller);

		protected:
			template <class Td>
			void UpdateConfigSingle(
				T         a_handle,
				const Td& a_params,
				bool      a_syncSex);

			void UpdateConfig(
				T                               a_handle,
				const NodeOverrideUpdateParams& a_params);

			template <class Td>
			bool EraseConfig(
				T                               a_handle,
				Data::configMapNodeOverrides_t& a_map,
				const stl::fixed_string&        a_name);

			template <class Td>
			void PostClear(
				const Td&                a_data,
				Td&                      a_workingData,
				const stl::fixed_string& a_name);

			void MergeProfileData(
				const profileSelectorParamsNodeOverride_t<T>& a_data,
				const NodeOverrideProfile&                    a_profile);

			void DrawPlayerDisabledWarning();

			bool IsConfigAutoGenerated(T a_handle) const;

		private:
			virtual void DrawMainHeaderControlsExtra(
				T                        a_handle,
				entryNodeOverrideData_t& a_data) override;

			virtual bool DrawExtraInfoAndWarnings(
				T                              a_handle,
				const entryNodeOverrideData_t& a_data) const override;

			virtual Data::configNodeOverrideHolder_t&
				GetOrCreateConfigHolder(T a_handle) const = 0;

			virtual Data::configNodeOverrideHolder_t*
				GetConfigHolder(T a_handle) const = 0;

			virtual NodeOverrideProfile::base_type GetData(
				const profileSelectorParamsNodeOverride_t<T>& a_params) override;
		};

		template <class T>
		UINodeOverrideEditorCommon<T>::UINodeOverrideEditorCommon(
			Controller& a_controller) :
			UINodeOverrideEditorWidget<T>(a_controller),
			UIProfileSelectorWidget<
				profileSelectorParamsNodeOverride_t<T>,
				NodeOverrideProfile>(
				UIProfileSelectorFlags::kEnableApply |
					UIProfileSelectorFlags::kEnableMerge)
		{
		}

		template <class T>
		template <class Td>
		void UINodeOverrideEditorCommon<T>::UpdateConfigSingle(
			T         a_handle,
			const Td& a_params,
			bool      a_syncSex)
		{
			auto& confEntry = GetOrCreateConfigHolder(a_handle)
			                      .get_data<decltype(a_params.entry.second)>()
			                      .try_emplace(a_params.name)
			                      .first->second;

			if (a_syncSex)
			{
				auto og = Data::GetOppositeSex(a_params.sex);

				a_params.entry.second(og) = a_params.entry.second(a_params.sex);
				confEntry                 = a_params.entry.second;
			}
			else
			{
				confEntry(a_params.sex) = a_params.entry.second(a_params.sex);
			}

			a_params.entry.first = this->GetConfigClass();
		}

		template <class T>
		void UINodeOverrideEditorCommon<T>::UpdateConfig(
			T                               a_handle,
			const NodeOverrideUpdateParams& a_params)
		{
			a_params.data.flags.clear(Data::NodeOverrideHolderFlags::RandomGenerated);
			a_params.data.copy_cc(
				this->GetConfigClass(),
				GetOrCreateConfigHolder(a_handle));
		}

		template <class T>
		template <class Td>
		bool UINodeOverrideEditorCommon<T>::EraseConfig(
			T                               a_handle,
			Data::configMapNodeOverrides_t& a_map,
			const stl::fixed_string&        a_name)
		{
			auto it = a_map.find(a_handle);
			if (it != a_map.end())
			{
				it->second.flags.clear(Data::NodeOverrideHolderFlags::RandomGenerated);

				bool r = it->second.get_data<Td>().erase(a_name) > 0;

				if (it->second.empty())
				{
					a_map.erase(it);
				}

				return r;
			}
			else
			{
				return false;
			}
		}

		template <class T>
		template <class Td>
		void UINodeOverrideEditorCommon<T>::PostClear(
			const Td&                a_data,
			Td&                      a_workingData,
			const stl::fixed_string& a_name)
		{
			if (auto it = a_data.find(a_name); it != a_data.end())
			{
				a_workingData.emplace(a_name, it->second);
			}
		}

		template <class T>
		void UINodeOverrideEditorCommon<T>::MergeProfileData(
			const profileSelectorParamsNodeOverride_t<T>& a_data,
			const NodeOverrideProfile&                    a_profile)
		{
			auto& conf  = GetOrCreateConfigHolder(a_data.handle);
			auto& pdata = a_profile.Data();

			for (auto& e : pdata.transformData)
			{
				conf.transformData.insert_or_assign(e.first, e.second);
			}

			for (auto& e : pdata.placementData)
			{
				conf.placementData.insert_or_assign(e.first, e.second);
			}
			
			for (auto& e : pdata.physicsData)
			{
				conf.physicsData.insert_or_assign(e.first, e.second);
			}

			conf.flags.set(pdata.flags);
			conf.flags.clear(Data::NodeOverrideHolderFlags::RandomGenerated);
		}

		template <class T>
		void UINodeOverrideEditorCommon<T>::DrawPlayerDisabledWarning()
		{
			ImGui::TextColored(
				UICommon::g_colorWarning,
				"%s",
				UIL::LS(UINodeOverrideEditorWidgetStrings::PlayerDisabledWarning));

			ImGui::Spacing();
			ImGui::Separator();
			ImGui::Spacing();
		}

		template <class T>
		bool UINodeOverrideEditorCommon<T>::IsConfigAutoGenerated(T a_handle) const
		{
			if (auto data = GetConfigHolder(a_handle))
			{
				return data->flags.test(Data::NodeOverrideHolderFlags::RandomGenerated);
			}
			else
			{
				return false;
			}
		}

		template <class T>
		void UINodeOverrideEditorCommon<T>::DrawMainHeaderControlsExtra(
			T                        a_handle,
			entryNodeOverrideData_t& a_data)
		{
			ImGui::Separator();

			if (this->TreeEx(
					"tree_prof",
					false,
					"%s",
					UIL::LS(CommonStrings::Profile)))
			{
				ImGui::Spacing();

				profileSelectorParamsNodeOverride_t params{ a_handle, a_data };

				ImGui::PushItemWidth(ImGui::GetFontSize() * -15.5f);

				this->DrawProfileSelector(params);

				ImGui::PopItemWidth();

				ImGui::Spacing();

				ImGui::TreePop();
			}
		}

		template <class T>
		bool UINodeOverrideEditorCommon<T>::DrawExtraInfoAndWarnings(
			T                              a_handle,
			const entryNodeOverrideData_t& a_data) const
		{
			bool result = false;

			if (IsConfigAutoGenerated(a_handle))
			{
				ImGui::Spacing();

				ImGui::PushStyleColor(ImGuiCol_Text, UICommon::g_colorWarning);
				ImGui::TextWrapped("%s", UIL::LS(UIWidgetCommonStrings::ConfigAutoGenerated));
				ImGui::PopStyleColor();

				result = true;
			}

			return result;
		}

		template <class T>
		NodeOverrideProfile::base_type UINodeOverrideEditorCommon<T>::GetData(
			const profileSelectorParamsNodeOverride_t<T>& a_params)
		{
			a_params.data.flags.clear(Data::NodeOverrideHolderFlags::RandomGenerated);
			return a_params.data.copy_cc(this->GetConfigClass());
		}
	}
}